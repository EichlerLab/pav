"""
Routines for handling alignments.
"""

import numpy as np


_INT_STR_SET = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
_CIGAR_OP_SET = {'M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X'}

# Indices for tuples returned by trace_cigar_to_zero()
TC_INDEX = 0
TC_OP_LEN = 1
TC_OP_CODE = 2
TC_DIFF_CUM = 3
TC_DIFF = 4
TC_EVENT_CUM = 5
TC_EVENT = 6
TC_SUB_BP = 7
TC_QRY_BP = 8
TC_CLIPS_BP = 9
TC_CLIPH_BP = 10


def trim_alignments(record_l, record_r, match_coord):
    """
    Trim ends of overlapping alignments until ends no longer overlap. In repeat-mediated events, aligners (e.g.
    minimap2) will align the same parts of a contig to both reference copies (e.g. large DEL) or two parts of a contig
    to the same region (e.g. tandem duplication). This function trims back the alignments using the CIGAR string until
    the overlap is resolved using a simple greedy algorithm that minimizes variation.

    For example, a large repeat-mediated deletion will have two reference copies, but one copy in the contig, and the
    single contig copy is aligned to both by breaking the alignment record into two (one up to the deletion, and one
    following it). If the contig coordinates were ignored, the alignment gap is smaller than the actual deletion event,
    and one or both sides of the deletion are filled with false variants. In this example, the alignment is walked-
    out from both ends of the deletion until there is no duplication of aligned contig (e.g. the alignment stops at
    one contig base and picks up at the next contig base). In this case, this function would be asked to resolve the
    contig coordinates (match_coord = "query").

    A similar situation occurs for large tandem duplications, except there is one copy in the reference and two
    (or more) in the contig. Aligners may align through the reference copy, break the alignment, and start a new
    alignment through the second copy in the contig. In this case, this function would be asked to resolve reference
    coordinates (match_coord = "subject").

    :param record_l: Pandas Series alignment record (generated by align_get_read_bed).
    :param record_r: Pandas Series alignment record (generated by align_get_read_bed).
    :param match_coord: "query" to trim contig alignments, or "subject" to match reference alignments.

    :return: A tuple of modified `record_l` and 'record_r`.
    """

    # Check arguments
    if match_coord not in {'query', 'subject'}:
        raise RuntimeError('Unknown match_coord parameter: {}: Expected "query" or "subject"'.format(match_coord))

    # Get cigar operations
    cigar_l = list(cigar_str_to_tuples(record_l))[::-1]
    cigar_r = list(cigar_str_to_tuples(record_r))

    # Get number of bases to trim
    if match_coord == 'query':
        diff_bp = record_l['QUERY_END'] - record_r['QUERY_POS']
    else:
        diff_bp = record_l['END'] - record_r['POS']

    # Find the number of upstream (l) bases to trim to get to 0 (or contig start)
    trace_l = trace_cigar_to_zero(cigar_l, diff_bp, record_l, match_coord == 'query')[::-1]

    # Find the number of downstream (r) bases to trim to get to 0 (or contig start)
    trace_r = trace_cigar_to_zero(cigar_r, diff_bp, record_r, match_coord == 'query')

    # For each upstream alignment cut-site, find the best matching downstream alignment cut-site. Not all cut-site
    # combinations need to be tested since trimmed bases and event count is non-decreasing as it moves away from the
    # best cut-site (residual overlapping bases 0 and maximum events consumed)

    # Find optimal cut sites.
    # cut_idx_l and cut_idx_r are indices to trace_l and trace_r. These trace records point to the last CIGAR operation to
    # survive the cut, although they may be truncated. The whole record will not be removed.
    cut_idx_l, cut_idx_r = find_cut_sites(trace_l, trace_r, diff_bp)

    # Check for no cut-sites. Should not occur at this stage
    if cut_idx_l is None or cut_idx_r is None:
        raise RuntimeError('Program bug: Found no cut-sites: {} ({}:{}) vs {} ({}:{}), match_coord={}'.format(
            record_l['QUERY_ID'], record_l['#CHROM'], record_l['POS'],
            record_r['QUERY_ID'], record_r['#CHROM'], record_r['POS'],
            match_coord
        ))

    # Get cut records
    cut_l = trace_l[cut_idx_l]
    cut_r = trace_r[cut_idx_r]

    # Set mid-record cuts (Left-align cuts, mismatch first)
    residual_bp = diff_bp - (cut_l[TC_DIFF_CUM] + cut_r[TC_DIFF_CUM])
    trim_l = 0
    trim_r = 0

    if residual_bp > 0 and cut_l[TC_OP_CODE] == 'X':  # Left mismatch
        trim_l += np.min([residual_bp, cut_l[TC_OP_LEN] - 1])
        residual_bp -= trim_l

    if residual_bp > 0 and cut_r[TC_OP_CODE] == 'X':  # Right mismatch
        trim_r += np.min([residual_bp, cut_r[TC_OP_LEN] - 1])
        residual_bp -= trim_r

    if residual_bp > 0 and cut_l[TC_OP_CODE] == '=':  # Left match
        trim_l += np.min([residual_bp, cut_l[TC_OP_LEN] - 1])
        residual_bp -= trim_l

    if residual_bp > 0 and cut_r[TC_OP_CODE] == '=':  # Right match
        trim_r += np.min([residual_bp, cut_r[TC_OP_LEN] - 1])
        residual_bp -= trim_r

    # Get cut CIGAR String
    cigar_l_mod = cigar_l[cut_l[TC_INDEX]:]
    cigar_r_mod = cigar_r[cut_r[TC_INDEX]:]

    # Shorten last alignment record if set.
    cigar_l_mod[0] = (cigar_l_mod[0][0] - trim_l, cigar_l_mod[0][1])
    cigar_r_mod[0] = (cigar_r_mod[0][0] - trim_r, cigar_r_mod[0][1])

    # Modify alignment records
    record_l_mod = record_l.copy()
    record_r_mod = record_r.copy()

    cut_sub_l = cut_l[TC_SUB_BP] + trim_l
    cut_qry_l = cut_l[TC_QRY_BP] + trim_l

    cut_sub_r = cut_r[TC_SUB_BP] + trim_r
    cut_qry_r = cut_r[TC_QRY_BP] + trim_r

    record_l_mod['END'] -= cut_sub_l
    record_l_mod['QUERY_END'] -= cut_qry_l
    record_l_mod['CLIP_R'] += cut_l[TC_CLIPS_BP] + trim_l

    record_r_mod['POS'] += cut_sub_r
    record_r_mod['QUERY_POS'] += cut_qry_r
    record_r_mod['CLIP_L'] += cut_r[TC_CLIPS_BP] + trim_r

    record_l_mod['CUT_REF_R'] += cut_sub_l
    record_l_mod['CUT_TIG_R'] += cut_qry_l

    record_r_mod['CUT_REF_L'] += cut_sub_r
    record_r_mod['CUT_TIG_L'] += cut_qry_r

    # Add clipped bases to CIGAR
    if cigar_l[0][1] == 'H':
        cigar_l_pre = [cigar_l[0]]
    else:
        cigar_l_pre = []

    if cigar_r[0][1] == 'H':
        cigar_r_pre = [cigar_r[0]]
    else:
        cigar_r_pre = []

    clip_s_l = cut_l[TC_CLIPS_BP] + cut_l[TC_QRY_BP] + trim_l
    clip_s_r = cut_r[TC_CLIPS_BP] + cut_r[TC_QRY_BP] + trim_r

    if clip_s_l > 0:
        cigar_l_pre.append((clip_s_l, 'S'))

    if clip_s_r > 0:
        cigar_r_pre.append((clip_s_r, 'S'))

    cigar_l_mod = cigar_l_pre + cigar_l_mod
    cigar_r_mod = cigar_r_pre + cigar_r_mod

    record_l_mod['CIGAR'] = ''.join([str(cigar_len) + cigar_op for cigar_len, cigar_op in cigar_l_mod[::-1]])
    record_r_mod['CIGAR'] = ''.join([str(cigar_len) + cigar_op for cigar_len, cigar_op in cigar_r_mod])

    return record_l_mod, record_r_mod


def find_cut_sites(trace_l, trace_r, diff_bp):
    """
    Find best cut-sites for left and right alignments to consume `diff_bp` bases.

    Optimize by:
    1) `diff_bp` or more bases removed.
    2) Maximize events (I, D, X)
    3) Tie-break by:
      a) Total removed bases closest to `diff_bp`.
      b) Left-align break

    :param trace_l: List of tuples for the left alignment generated by `trace_cigar_to_zero()`. This list
        should be reversed after it was generated (traversed start to end).
    :param trace_r: List of tuples for the right alignment generated by `trace_cigar_to_zero()`.
    :param diff_bp: Target removing this many bases. Could be subject (ref) or query (tig) depending on how the
        traces were constructed.

    :return: Tuple of (cut_idx_l, cut_idx_r). cut_idx_l and cut_idx_r are the left contig and right contig cigar list index (argument to
        trace_cigar_to_zero()), index element of `trace_l` and `trace_r`) where the alignment cuts should occur.
    """

    # Right-index traversal
    tc_idx_r = 0        # Current right-index
    #tc_idx_r_last = -1  # Last right-index. Used for early-exit.

    len_r = len(trace_r)  # End of r-indexes

    # Optimal cutsite for this pair of alignments
    cut_idx_l = None
    cut_idx_r = None
    
    max_event = 0
    max_diff = None

    # Debugging: List of operations
    diff_list_op = list()  # DBGTMP

    # Traverse l cut-sites
    for tc_idx_l in range(len(trace_l)):

        # Optimal cutsite for this pair of alignments at a given left index.
        cut_idx_part_l = None
        cut_idx_part_r = None

        max_event_part = 0
        max_diff_part = None

        # Note: "=" and "X" consume both subj and qry, so diff calculation is the same if subject or query is cut.
        # The following code assumes an = or X record is being processed.

        # Get min and max base differences achievable by cutting at the end or beginning of this l-record.
        min_bp_l = trace_l[tc_idx_l][TC_DIFF_CUM]
        max_bp_l = trace_l[tc_idx_l][TC_DIFF_CUM] + trace_l[tc_idx_l][TC_DIFF] - 1  # Cut all but one left base

        # Traverse r cut-sites until max-left + max-right base difference diff_bp or greater.
        while (
                tc_idx_r + 1 < len_r and
                max_bp_l + trace_r[tc_idx_r][TC_DIFF_CUM] + trace_r[tc_idx_r][TC_DIFF] - 1 < diff_bp  # Cut all but one right base
        ):
            tc_idx_r += 1

        # Traverse all cases where max-cutting the left event crosses 0 residual bases (or the single case resulting in
        # over-cutting).
        tc_idx_r_start = tc_idx_r

        while (
                tc_idx_r < len_r and (
                    min_bp_l + trace_r[tc_idx_r][TC_DIFF_CUM] <= diff_bp or
                    tc_idx_r == tc_idx_r_start  # Find at least one cut-site on the right side, even if it over-cuts.
                )
        ):

            # Collect cut-site stats
            min_bp = min_bp_l + trace_r[tc_idx_r][TC_DIFF_CUM]
            max_bp = max_bp_l + trace_r[tc_idx_r][TC_DIFF_CUM] + trace_r[tc_idx_r][TC_DIFF] - 1

            diff_min = diff_bp - max_bp
            diff_max = diff_bp - min_bp

            # Count number of events if the minimal cut at these sites are made.
            event_count = trace_l[tc_idx_l][TC_EVENT_CUM] + trace_r[tc_idx_r][TC_EVENT_CUM]

            if diff_min <= diff_bp:
                # Target cut length is within the minimum and maximum bp by cutting at this site

                # Add up to bases_mismatch (number of X sites) to cut at target length (diff_bp)
                event_count += np.min([
                    # Difference on min-bases to target
                    diff_bp - diff_min,

                    # Number of events that could be added if either or both ends X and are fully cut
                    trace_l[tc_idx_l][TC_EVENT] + trace_r[tc_idx_r][TC_EVENT]
                ])

                diff_optimal = 0  # diff_bp is exactly achievable
            else:
                # Must over-cut to use these sites.
                diff_optimal = diff_bp - diff_min

            # else: Cut will remove more than the target number of bases; do not cut into these (accept full records)

            # DBGTMP: Turn on to get full list
            diff_list_op.append(
                (
                    tc_idx_l, tc_idx_r,
                    trace_l[tc_idx_l][TC_INDEX],
                    trace_r[tc_idx_r][TC_INDEX],
                    diff_optimal,
                    event_count
                )
            )

            # Save max
            if (
                event_count > max_event_part or (  # Better event count, or
                    event_count == max_event_part and (  # Same event count, and
                        max_diff_part is None or diff_optimal > max_diff_part  # Max difference is closer to 0 (less over-cut)
                    )
                )
            ):
                cut_idx_part_l = tc_idx_l
                cut_idx_part_r = tc_idx_r
                max_event_part = event_count
                max_diff_part = diff_optimal

            tc_idx_r += 1

        # Save max
        if (
            max_event_part > max_event or (  # Better event count, or
                max_event_part == max_event and (  # Same event count, and
                    max_diff is None or max_diff_part > max_diff  # Max difference is closer to 0 (less over-cut)
                )
            )
        ):
            cut_idx_l = cut_idx_part_l
            cut_idx_r = cut_idx_part_r
            max_event = max_event_part
            max_diff = max_diff_part

        # Reset right index
        if cut_idx_part_r is not None:
            tc_idx_r = cut_idx_part_r
        else:
            tc_idx_r = tc_idx_r_start

        #tc_idx_r_last = tc_idx_r

    return cut_idx_l, cut_idx_r


def trace_cigar_to_zero(cigar_list, diff_bp, aln_record, diff_query):
    """
    Trace CIGAR operations back until diff_bp query bases are discarded from the alignment. CIGAR operations must only
    contain operators "IDSH=X" (no "M"). The list returned is only alignment match ("=" or "X" records) for the
    optimal-cut algrothm (can only cut at aligned bases).

    Returns a list of tuples for each CIGAR operation traversed:
        * TC_INDEX = 0: Index in cigar_list.
        * TC_OP_LEN = 1: CIGAR operation length.
        * TC_OP_CODE = 2: CIGAR operation code (character, e.g. "I", "=").
        * TC_DIFF_CUM = 3: Cumulative base difference up this event, but not including it.
        * TC_DIFF = 4: Base difference for this event. Will be oplen depending on the operation code.
        * TC_EVENT_CUM = 5: Cumulative event difference (number of insertions, deletions, and SNVs) up to this event,
            but not including it.
        * TC_EVENT = 6: Event differences for this event. "1" for insertions or deletions, OP_LEN for mismatches
            "X", SNV).
        * TC_SUB_BP = 7: Cumulative number of subject (ref) bases consumed up to this event, but not including it.
        * TC_QRY_BP = 8: Cumulative number of query (tig) bases consumed up to this event, but not including it.
        * TC_CLIPS_BP = 9: Cumulative number of soft-clipped bases up to AND INCLUDING this event. Alignments are not
            cut on clipped records, so cumulative and including does not affect the algorithm.
        * TC_CLIPH_BP = 10: Cumulative number of hard-clipped bases up to AND INCLUDING this event.

    :param cigar_list: List of cigar operation tuples (cigar_len, cigar_op) with cigar_op as characters (e.g. "X", "=").
    :param diff_bp: Number of query bases to trace back. Final record will traverse past this value.
    :param aln_record: Alignment record for error reporting.
    :param diff_query: Compute base differences for query (tig) sequence if `True`. If `False`, compute for subject
        (reference).

    :return: A list of tuples tracing the effects of truncating an alignment at a given CIGAR operation.
    """

    index = 0
    index_end = len(cigar_list)

    cigar_count = 0

    diff_cumulative = 0
    event_cumulative = 0

    sub_bp_sum = 0
    qry_bp_sum = 0
    clip_s_sum = 0
    clip_h_sum = 0

    trace_list = list()

    while index < index_end and (diff_cumulative <= diff_bp or cigar_list[index][1] not in {'=', 'X'}):
        cigar_count += 1
        cigar_len, cigar_op = cigar_list[index]

        if cigar_op == '=':
            event_count = 0

            sub_bp = cigar_len
            qry_bp = cigar_len

        elif cigar_op == 'X':
            event_count = cigar_len

            sub_bp = cigar_len
            qry_bp = cigar_len

        elif cigar_op == 'I':
            event_count = 1

            sub_bp = 0
            qry_bp = cigar_len

        elif cigar_op == 'D':
            event_count = 1

            sub_bp = cigar_len
            qry_bp = 0

        elif cigar_op == 'S':
            event_count = 0

            sub_bp = 0
            qry_bp = 0

            clip_s_sum += cigar_len

        elif cigar_op == 'H':
            event_count = 0

            sub_bp = 0
            qry_bp = 0

            clip_h_sum += cigar_len

        else:
            raise RuntimeError((
                'Illegal operation in contig alignment while trimming alignment: {}{} '
                '(start={}:{}): CIGAR operation #{}: Expected CIGAR op in "IDSH=X"'
            ).format(cigar_len, cigar_op, aln_record['#CHROM'], aln_record['POS'], index))

        # Get number of bases affected by this event
        if diff_query:
            diff_change = qry_bp
        else:
            diff_change = sub_bp

        # Add to trace list
        if cigar_op in {'=', 'X'}:
            trace_list.append(
                (
                    index,
                    cigar_len, cigar_op,
                    diff_cumulative, diff_change,
                    event_cumulative, event_count,
                    sub_bp_sum, qry_bp_sum,
                    clip_s_sum, clip_h_sum
                )
            )

        # Increment cumulative counts
        diff_cumulative += diff_change
        event_cumulative += event_count

        sub_bp_sum += sub_bp
        qry_bp_sum += qry_bp

        index += 1

    return trace_list


def cigar_str_to_tuples(record):
    """
    Get an iterator for cigar operation tuples. Each tuple is (cigar-len, cigar-op).

    :param record: Alignment record.

    :return: Iterator of CIGAR operation tuples.
    """

    cigar = record['CIGAR']

    pos = 0
    max_pos = len(cigar)

    while pos < max_pos:

        len_pos = pos

        while cigar[len_pos] in _INT_STR_SET:
            len_pos += 1

        if len_pos == pos:
            raise RuntimeError('Missing length in CIGAR string for contig {} alignment starting at {}:{}: CIGAR index {}'.format(
                record['QUERY_ID'], record['#CHROM'], record['POS'], pos
            ))

        if cigar[len_pos] not in _CIGAR_OP_SET:
            raise RuntimeError('Unknown CIGAR operation for contig {} alignment starting at {}:{}: CIGAR operation {}'.format(
                record['QUERY_ID'], record['#CHROM'], record['POS'], cigar[pos]
            ))

        yield((int(cigar[pos:len_pos]), cigar[len_pos]))

        pos = len_pos + 1
